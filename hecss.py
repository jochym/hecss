#!/usr/bin/env python

_ver_mjr, _ver_min = 0, 1

import sys
import ase
import scipy
from scipy import stats
import numpy as np
from numpy import log, exp, sqrt, linspace, dot
import matplotlib.pyplot as plt 
import ase.units as un


def plot_stats(confs, nat, T=300, show=True):
    '''
    Plot monitoring histograms for the configuration list in confs.
    If len(confs)<3 this function is silent.

    confs - configuration list
    nat   - number of atoms in the structure
    T     - target temperature in Kelvin
    show  - call show() fuction at the end (default:True)
    '''

    if len(confs) < 3:
        return

    es = np.array([c[3] for c in confs])
    E_goal = 3*T*un.kB/2
    Es = sqrt(3/2)*un.kB*T/sqrt(nat)
    e = linspace(E_goal - 3*Es, E_goal + 3*Es, 200)
    n = len(es)
    
    plt.hist(es, bins='auto', density=True, label=f'{n} samples')
    h = np.histogram(es, bins='auto', density=False)
    de = (h[1][-1]-h[1][0])/len(h[0])
    plt.errorbar((h[1][:-1]+h[1][1:])/2, h[0]/h[0].sum()/de, 
             yerr=sqrt(h[0])/h[0].sum()/de, ls='', label='$1/\\sqrt{N}$')
    plt.axvline(E_goal, ls='--', color='C2', label='Target energy');
    plt.plot(e,  stats.norm.pdf(e, E_goal, Es), '--', label='Target normal dist.')
    fit = stats.norm.fit(es)
    plt.plot(e,  stats.norm.pdf(e, *fit), '--', label='Fitted normal dist.')
    fit = stats.chi2.fit(es, f0=3*nat)
    plt.plot(e,  stats.chi2.pdf(e, *fit), '--', label='Fitted $\\chi^2$ dist.')
    plt.xlabel('Potential energy (eV/at)')
    plt.ylabel('Probability density')
    plt.xlim(E_goal-3*Es,E_goal+3*Es)
    plt.legend()
    if show :
        plt.show()    

def normalize_conf(c, base):
    cell = base.get_cell()
    spos = c.get_scaled_positions()
    bspos = base.get_scaled_positions()

    # Unwrap the displacement relative to base
    sdx = spos - bspos
    sht = (sdx < -0.5)*1 - (sdx > 0.5)*1
    sdx += sht

    # Check if fractional displacements are below 1/3
    assert (abs(sdx) < 1/3).all()

    # Calculate unwrapped spos
    spos = bspos + sdx

    # Return carthesian positions, fractional positions
    return dot(spos,cell.T), spos


def write_dfset(fn, c, n=0):
    '''
    Append displacement-force data from the conf to the fn file.
    The format is suitable for use as ALAMODE DFSET file.
    Optionaly you can provide configuration number in n.
    File need not exist prior to first call. 
    If it does not it will be created.
    '''
    i, x, f, e = c
    with open(fn, 'at') as dfset:
        print(f'# set: {n:04d} config: {i:04d}  energy: {e:8e} eV/at', file=dfset)
        for ui, fi in zip(x,f):
            print((3*'%15.7f ' + '     ' + 3*'%15.8e ') % 
                        (tuple(ui/un.Bohr) + tuple(fi*un.Bohr/un.Ry)), 
                        file=dfset)
    

def HECSS(cryst, calc, T_goal, delta=0.05, width=0.033, maxburn=20, directory=None, verb=True):
    '''
    Run HECS sampler on the system `cryst` using calculator `calc` at target
    temperature `T_goal`. The `delta`, `width`, `maxburn` and `directory` parameters
    determine detailed aspects of the algorithm.

    This is a generator and cannot be used as regular function. 
    It is intended to be used as a source of the sequence of 
    configurations in the `for` loop and must be closed after 
    finishing the iteration. On the other hand, the iteration 
    may be continued if additional samples are required. 
    The state is preserved until the .close() method is called.

    ```
    sampler = HECSS(cryst, calc, T)
    for i, x, f, e in sampler:
        process_sample(i, x, f, e)
        if i > N :
            break
    sampler.close()
    ```

    INPUT
    =====
    cryst   - ASE structure to sample
    calc    - ASE calculator to use for potential energy evaluations
    T_goal  - Target temperature in Kelvin

    delta   - speed of the adaptation - maximal change of the prior width in one step
    width   - initial width of the position distribution in Angstrom
    maxburn - max number of burn-in steps

    directory - directory for calculations and generated samples. If left as None,
                the `calc/{T_goal:.1f}K/` will be used and the generated samples will be 
                stored in the `smpl/{i:04d}` subdirectories.

    verb    - print verbose progress messages for interactive use

    OUTPUT
    ======
    The generator yields samples from the thermodynamic distribution at T=T_goal as tuples
    (index, displacement, forces, energy):
    index        - integer numbering the samples in the `smpl` subdirectory. The index may
                   repeat if the sample must be repeated in the sequence. 
    displacement - set of atomic displacements (in A) in the sample (numpy array)
    forces       - set of forces (in eV/A) generated by the displacement
    energy       - potential energy of the configuration

    '''    

    if verb:
        print(f'Calculating initial config.', end='\r')
        sys.stdout.flush()

    nat = cryst.get_global_number_of_atoms()
    dim = (nat, 3)
    Ep0 = cryst.get_potential_energy()
    
    E_goal = 3*T_goal*un.kB/2
    Es = np.sqrt(3/2)*un.kB*T_goal/np.sqrt(nat)   
    
    P = stats.norm.pdf
    Q = stats.norm
    
    w = width
    w_prev = w
    x = Q.rvs(size=dim, scale=w)
    
    i = 0
    n = 0
    
    if directory is None :
        basedir = f'calc/T_{T_goal:.1f}K'
    else :
        basedir = directory

    cr = ase.Atoms(numbers = cryst.get_atomic_numbers(), 
                   cell=cryst.get_cell(),
                   scaled_positions=cryst.get_scaled_positions(),
                   pbc=True, calculator=calc)
    
    cr.set_positions(cryst.get_positions()+x)
    cr.calc.set(directory=f'{basedir}/smpl/{i:04d}')
    
    e = (cr.get_potential_energy()-Ep0)/nat
    f = cr.get_forces()
    
    a = 0
    k = 0
    
    if verb:
        print(f'Starting burn-in.            ', end='\r')
        sys.stdout.flush()

    while True:
        x_star = Q.rvs(size=dim, scale=w)

        cr.set_positions(cryst.get_positions()+x_star)
        cr.calc.set(directory=f'{basedir}/smpl/{i:04d}')

        e_star = (cr.get_potential_energy()-Ep0)/nat
        f_star = cr.get_forces()
        
        alpha = P(e_star, E_goal, Es) / P(e, E_goal, Es)
        
        q_x = log(Q.pdf(x, w_prev)).sum()
        q_star_x_star = log(Q.pdf(x_star, w)).sum()
        q_star_x = log(Q.pdf(x, w)).sum()
        q_x_star = log(Q.pdf(x_star, w_prev)).sum()

        alpha *= exp(q_x + q_star_x_star - q_star_x - q_x_star)

        w_prev = w
        w *= 1-2*(scipy.special.expit((e_star-E_goal)/Es)-0.5)*delta
        
        if np.random.rand() < alpha:
            x = x_star
            e = e_star
            f = f_star
            if i==0 and abs(e_star-E_goal) > 2*Es :
                # At the burn-in stage and still further then 2 sigma from target
                # Let us keep searching for correct w
                pass
            else :
                i += 1
                a += 1

        if i==0 :
            k+=1
            if verb:
                print(f'Burn-in sample:{k}  w:{w:.4f}  alpha:{alpha:6.4f}  dE:{abs(e_star-E_goal)/(2*Es):6.2f} sigma', end='\r')
                sys.stdout.flush()
            if k>maxburn :
                return
            continue
        else :    
            n += 1
            if verb:
                print(f'Sample:{n:<5d}  conf:{i-1:04d}  a:{100*a/n:5.1f}%  w:{w:.4f}  alpha:{alpha:6.4f}', end='\r')
                sys.stdout.flush()
        yield i-1, x, f, e
        
        

if __name__ == '__main__':

    from ase.calculators.vasp import Vasp2, Vasp
    from ase.build import bulk
    import os, errno

    def mkdirs(newdir, mode=0o777):
        try: os.makedirs(newdir, mode)
        except OSError as err:
            # Reraise the error unless it's about an already existing directory 
            if err.errno != errno.EEXIST or not os.path.isdir(newdir): 
                raise


    print(f'HECS sampler ver.:{_ver_mjr}.{_ver_min}')
        
    n = 1
    a = 4.37165779
    #a = 4.38447739 # Approx 600K thermal expansion
    uc = bulk('SiC', crystalstructure='zincblende', a=a, cubic=True)
    uc = ase.build.sort(uc, tags= uc.get_masses())
    cryst = uc.repeat(n)
    cryst = ase.build.sort(cryst, tags= cryst.get_masses())
    
    calc = Vasp2(label='calc', directory='calc', xc='pbe',
                 command=f'~/devel/scripts/run-vasp/run-vasp54' + 
                 f' -b -N 1 -p 64 -q blade2 -J "sc_{n}x{n}x{n}"')
    
    cryst.set_calculator(calc)
    
    cryst.calc.set(kpts=[3,3,3], ibrion=1, isif=3, nsw=0, nelm=60,
                   ediff=1e-8, ncore=8, 
                   lcharg=False, lwave=False, isym=0)
    
    cryst.calc.set(directory='calc')
    
    print(f'P_0:{cryst.get_stress()[:3].mean()/un.GPa:0.4f} GPa') 
    
    T_goal = 2000
    nat = cryst.get_global_number_of_atoms()
    E_goal = 3*T_goal*un.kB/2
    Es = np.sqrt(3/2)*un.kB*T_goal/np.sqrt(nat)   
    
    idx = []
    xs = []
    fs = []
    es = []
    dfsetfn = f'calc/T_{T_goal:.1f}K/'
    mkdirs(f'calc/T_{T_goal:.1f}K/')
    dfsetfn = dfsetfn + 'DFSET'

    with open(dfsetfn , 'wt') as dfset:
        print(f'# Data from HECS sampling at {T_goal:.1f}K', file=dfset)

    sampler = HECSS(cryst, calc, T_goal)
    
    N=64
    for i, x, f, e in sampler:
        idx.append(i)
        xs.append(x)
        fs.append(f)
        es.append(e)
        with open(dfsetfn, 'at') as dfset:
            print(f'#\n# set: {len(idx)}  config: {i:04d}  energy: {e:8e} eV/at\n#', file=dfset)
            for ui, fi in zip(x,f):
                print(*tuple(ui/un.Bohr), *tuple(fi*un.Bohr/un.Ry), file=dfset)
        if len(idx) >= N:
            break
            
            
    sampler.close()
            
            
    