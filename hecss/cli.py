"""The command line interface for the HECSS sampler"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../02_CLI.ipynb.

# %% auto 0
__all__ = []

# %% ../02_CLI.ipynb 2
import click
from pathlib import Path
import os
import ase
from ase.calculators.vasp import Vasp
from ase import units as un
from numpy import savetxt, loadtxt, array
from hecss import *
import hecss
from hecss.util import write_dfset, calc_init_xscale
from hecss.optimize import make_sampling
import traceback
from tempfile import TemporaryDirectory
import ast

# %% ../02_CLI.ipynb 5
_version_message=("HECSS, version %(version)s\n"
                  'High Efficiency Configuration Space Sampler\n'
                  '(C) 2021-2024 by PaweÅ‚ T. Jochym\n'
                  '    License: GPL v3 or later')

# %% ../02_CLI.ipynb 6
def run_cli_cmd(cmd, args, prt_result=False):
    print(f'$ {cmd.name} {args}\n')
    run = CliRunner().invoke(cmd, args) 
    print(run.output)
    if prt_result or run.exit_code!=0:
        print(run)
        if run.exit_code!=0:
            traceback.print_tb(run.exc_info[-1])        

# %% ../02_CLI.ipynb 7
def dfset_writer(s, sl, workdir='', dfset='', scale='', xsl=None):
    '''
    Write samples to the DFSET file in the workdir directory.
    If the scale and xsl list are not empy save amplitude correction 
    and empty the xsl list (!).
    '''
    wd = Path(workdir)
    write_dfset(f'{wd.joinpath(dfset)}.raw', s)
    if scale and xsl:
        with open(wd.joinpath(scale), 'at') as sf:
            for xs in xsl:
                savetxt(sf, xs, fmt='%8.5f', header=f'{xs.shape}, {len(sl)}, {len(xsl)}')
        xsl.clear()
    # Important! Return False to keep iteration going
    return False

# %% ../02_CLI.ipynb 8
@click.command()
@click.argument('fname', type=click.Path(exists=True))            
@click.option('-W', '--workdir', default="WORK", type=click.Path(exists=True), help="Work directory")
@click.option('-l', '--label', default="hecss", help="Label for the calculations.")
@click.option('-T', '--temp', default=300, type=float, help="Target temperature in Kelvin.")
@click.option('-w', '--width', default=None, type=float, help="Initial scale of the prior distribution")
@click.option('-a', '--ampl', default='', type=click.Path(), help='Initialise amplitude correction from the file.')
@click.option('-s', '--scale', default='', type=click.Path(), help='Save amplitude correction history')
@click.option('-m', '--symprec', default=1e-5, type=float, help='Symmetry search tolerance.')
@click.option('-C', '--calc', default="VASP", type=str, 
              help="ASE calculator to be used for the job. "
                      "Supported calculators: VASP (default)")
@click.option('-S', '--setups', default="guess", type=str,
              help="setups parameter of the calculator to force use of the "
                   "particular variants of pseudopotentials in the calculations. "
                   "By default pseudopotentials are guessed from the POTCAR in "
                   "the supercell directory.")
@click.option('-n', '--nodfset', is_flag=True, default=False, help='Do not write DFSET file for ALAMODE')
@click.option('-d', '--dfset', default='DFSET.dat', help='Name of the DFSET file')
@click.option('-N', '--nsamples', default=10, type=int, help="Number of samples to be generated")
@click.option('-e', '--neta', default=2, type=int, help="Number of samples for width scale estimation")
@click.option('-c', '--command', default='./run-calc', help="Command to run calculator")
@click.option('-k', '--nwork', default=None, type=int, help="Number of parallel workers to run (0=unlimited)")
@click.option('-p', '--pbar', is_flag=True, default=True, help="Do not show progress bar")
@click.version_option(hecss.__version__, '-V', '--version', message=_version_message)
@click.help_option('-h', '--help')
def hecss_sampler(fname, workdir, label, temp, width, ampl, scale, symprec, calc, setups, nodfset, dfset, nsamples, neta, command, nwork, pbar):
    '''
    Run HECSS sampler on the structure in the provided file (FNAME).\b
    Read the docs at: https://jochym.github.io/hecss/
    
    \b
    FNAME - Supercell structure file. The containing 
            directory must be readable by Vasp(restart).
            Usually this is a CONTCAR file for a supercell.
    '''
    
    print(f'HECSS ({hecss.__version__})\n'
          f'Supercell:      {fname}\n'
          f'Temperature:    {temp}K\n'
          f'Work directory: {workdir}\n'
          f'Calculator:     {calc}')
    
    src_path = Path(fname)
    Ep0 = None
    if calc=="VASP":
        calculator = Vasp(label=label, directory=src_path.parent, restart=True)
        Ep0 = calculator.get_potential_energy()
        cryst = ase.Atoms(calculator.atoms)
        cryst.calc = calculator
        calculator.set(directory=workdir)
        command = Path(command)
        calculator.set(command=f'{command.absolute()} {label}')
        calculator.set(nsw=0)
        if setups :
            if setups=='guess':
                setups = {}
                with open(src_path.parent / Path("POTCAR"), "r") as pf:
                    for l in pf.readlines():
                        if "TITEL" in l:
                            l = l.strip().split()[3].split("_")
                            el = l[0]
                            st = ""
                            if len(l)>1:
                                st = f"_{l[1]}"
                            setups[el] = st
                print(f"Setups guessed from {src_path.parent / Path('POTCAR')}: {setups}")
            else :
                if setups in {'recommended', 'minimal', 'gw'}:
                # We do not need to parse these. Just use as is
                    pass
                else :
                # Parse into dict
                    setups = ast.literal_eval(setups)
                print(f"Setups forced: {setups}")
            calculator.set(setups=setups)
    else:
        print(f'The {calc} calculator is not supported.')
        return
    
    if nodfset :
        sentinel = None
    else :
        sentinel = dfset_writer
    
    xsl = None
    if scale:
        xsl = []

    wl = []
        
    sampler = HECSS(cryst, calculator, directory=workdir, width=width, pbar=pbar)
    sampler.Ep0 = Ep0
    
    if ampl:
        sampler.xscale_init = loadtxt(ampl)
    
    if width is None and neta > 0:
        print('Estimating width scale.')
        eta, sigma, xscale = sampler.estimate_width_scale(neta, Tmin=temp/2, Tmax=temp, pbar=sampler._pbar, nwork=nwork)
        if nsamples <= 1:
            print(f'Width scale from {neta} pts.: {eta:.3g}+/-{sigma:.3g}')
            print('Width scale estimation run (N<2). Not running sampling.')
            return

    print('Sampling configurations')
    samples = sampler.sample(temp, nsamples,
                             width_list=wl, 
                             sentinel=dfset_writer,
                             sentinel_args={'workdir': f'{workdir}/T_{temp:.1f}K/',
                                              'dfset': dfset,
                                              'scale': scale,
                                              'xsl': xsl
                                             },
                             xscale_list=xsl,
                             symprec=symprec)
    # generate distribution centered at mean energy
    T_m = 2*array([s[-1] for s in samples]).mean()/3/un.kB
    print(f'Generating distribution centered at: {T_m:.3f} K')
    distr = sampler.generate(samples, T_m)
    if len(wl)>1 :
        wl = array(wl).T
        # print(wl.shape)
        print(f'Average width scale ({len(wl[0])} pnts): {wl[0].mean():.3g}+/-{wl[0].std():.3g}')
    
    if not nodfset:
        wd = Path(workdir)
        for s in distr:
            write_dfset(f'{wd.joinpath(dfset)}', s)
        
    return

# %% ../02_CLI.ipynb 17
@click.command()
@click.argument('supercell', type=click.Path(exists=True))
@click.argument('scale', type=click.Path(exists=True))
@click.option('-o', '--output', type=click.Path(), default="", help='Write output to the file.')
@click.option('-s', '--skip', default=0, type=int, help='Skip this number of samples at the beginning')
@click.version_option(hecss.__version__, '-V', '--version', message=_version_message)
@click.help_option('-h', '--help')
def calculate_xscale(supercell, scale, output, skip):
    '''
    Calculate initial values for amplitude correction coefficients 
    from the scale file data for the specified supercell.
    '''
    sc = ase.io.read(supercell)
    xsl = loadtxt(scale).reshape((-1, len(sc), 3))
    xsi = calc_init_xscale(sc, xsl, skip=skip if skip else None)
    savetxt(output, xsi, fmt='%9.4f')
    print(f'Done. The initial scale saved to: {output}')

# %% ../02_CLI.ipynb 22
@click.command()
@click.argument('dfset', type=click.Path(exists=True))
@click.argument('T', default=-1, type=float)
@click.option('-N', '--nmul', default=4, type=int, help="Sample length multiplier (default: 4)")
@click.option('-p', '--prob', type=float, default=0.25, help='Probability treshold (default: 0.25)')
@click.option('-w', is_flag=True, default=True, help='Force non-zero weights for samples above probability treshold. (default: True)')
@click.option('-b', is_flag=True, default=False, help='Border samples account for the rest of domain')
@click.option('-c', '--check', type=click.Path(), default="", help='Check and skip unconverged samples in calc directory.')
@click.option('-o', '--output', type=click.Path(), default="", help='Write output to the file.')
@click.option('-d', is_flag=True, default=False, help='Plot debug plots')
@click.version_option(hecss.__version__, '-V', '--version', message=_version_message)
def reshape_sample(dfset, t, nmul, prob, w, check, b, output, d):
    '''
    Reshape the sample to the normal distribution centered around mean energy (temperature),
    or around provided temperature T (Kelvin). The reshaping is done by adjusting weighting
    of the samples by repeating the ones which should be up-weighted. 
    The parameters are the variants of the weighting algorithm (see the docs).\b
    
    The procedure reads and produces a file with in the DFSET format.
    For the 'check' function to work the parameter must point to the root directory 
    of the calculated samples. The checked directories will be in the form: '{root}/nnnn'.  

    In check mode the raw file is *not* reshaped, just filtered.
    '''
    from hecss.util import load_dfset
    p = Path(dfset)
    smpl = load_dfset(p)

    if check :
        from tqdm.auto import tqdm
        print(f"Checking convergence in {check}/nnnn")
        configs = {i for n, i, x, f, e in smpl}
        converged = {i for i in tqdm(configs)
                     if Vasp(restart=True, directory=f'{check}/{i:04d}').converged}
        print(f"Number of converged calculations: {len(converged)}/{len(configs)}")
        dist = [s for s in smpl if s[1] in converged]
        print(f"Rewriting the raw dfset (skipping reshape).")
    else :
        if t < 0:
            t = 2*array([s[-1] for s in smpl]).mean()/3/un.kB 
        dist = make_sampling(smpl, t, border=b, probTH=prob, Nmul=nmul, nonzero_w=w, debug=d)
        print(f'Done. Distribution reshaped to {t:.2f} K.')

    print(f'Done. Saving to: {output}')
    for s in dist:
        write_dfset(output, s)


# %% ../02_CLI.ipynb 26
@click.command()
@click.argument('dfset', type=click.Path(exists=True))
@click.argument('T', default=-1, type=float)
@click.option('-n', '--sqrn', is_flag=True, help='Show sqrt(N) bars on the histogram.')
@click.option('-s', '--sixel', is_flag=True, help='Use SixEl driver for terminal graphics.')
@click.option('-w', '--width', type=float, default=6, help='Width of the figure.')
@click.option('-h', '--height', type=float, default=4, help='Height of the figure.')
@click.option('-o', '--output', type=click.Path(), default="", help='Write output to the file.')
@click.option('-x', is_flag=True, default=False, help='Make plot in an interactive window')
@click.version_option(hecss.__version__, '-V', '--version', message=_version_message)
def plot_stats( dfset, t, output, x, sixel, sqrn, width, height):
    """
    Plot the statistics of the samples from the DFSET file.
    Use T(K) as a reference target temperature. Optionally 
    write out the plot to the output graphics file.
    """
    from hecss.util import load_dfset
    from hecss.monitor import plot_stats
    import matplotlib.pylab as plt

    p = Path(dfset)
    smpl = load_dfset(p)
    plt.figure(figsize=(float(width), float(height)))
    plot_stats(smpl, T=t if t >0 else None, sqrN=sqrn, show=x)
    if output:
        plt.savefig(output)
    if sixel:
        try :
            import sixelplot
        except ImportError:
            print('SixEl graphics support not installed. Install sixelplot package.')
            return
        sixelplot.show()

# %% ../02_CLI.ipynb 31
@click.command()
@click.argument('bands', type=click.Path(exists=True), nargs=-1)
@click.option('-s', '--sixel', is_flag=True, help='Use SixEl driver for terminal graphics.')
@click.option('-n', '--nodecor', is_flag=True, help='Decorate the plot.')
@click.option('-w', '--width', type=float, default=6, help='Width of the figure.')
@click.option('-h', '--height', type=float, default=4, help='Height of the figure.')
@click.option('-o', '--output', type=click.Path(), default="", 
              help='Write output to the file.')
@click.option('-l', '--label', type=str, default="", 
              help='Label(s) for the plot. Comma-separated list')
@click.option('-x', is_flag=True, default=False, 
              help='Make plot in an interactive window')
@click.version_option(hecss.__version__, '-V', '--version', message=_version_message)
def plot_bands( bands, output, x, sixel, width, height, label, nodecor):
    """
    Plot the phonon dispersion from the file generated by ALAMODE.
    Optionally write out the plot to the output graphics file.
    """
    import hecss.monitor as hm
    import matplotlib.pylab as plt

    
    plt.figure(figsize=(float(width), float(height)))

    ll = label.split(',')
    if len(ll) < len(bands):
        cp = os.path.commonpath(bands)
        rpl = [p[len(cp):][::-1] for p in bands]
        cs = os.path.commonpath(rpl)
        ll = [p[len(cp):-len(cs)] for p in bands]

    for b, l in zip(bands, ll):
        p = Path(b)

        hm.plot_bands_file(p, lbl=l, decorate=not nodecor)

    if label or len(bands)>1:
        plt.legend()

    if output:
        plt.savefig(output)
    if sixel:
        try :
            import sixelplot
        except ImportError:
            print('SixEl graphics support not installed. Install sixelplot package.')
            return
        sixelplot.show()
