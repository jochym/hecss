# AUTOGENERATED! DO NOT EDIT! File to edit: ../12_optimize.ipynb.

# %% auto 0
__all__ = ['get_sample_weights', 'make_sampling']

# %% ../12_optimize.ipynb 2
from scipy import stats
from matplotlib import pylab as plt
import ase.units as un
import numpy as np
import itertools 

# %% ../12_optimize.ipynb 3
flatten = itertools.chain.from_iterable

# %% ../12_optimize.ipynb 8
def get_sample_weights(data, T, sigma_scale=1.0, debug=False):
    nat = data[0][2].shape[0]
    mu = 3*T*un.kB/2
    sigma = np.sqrt(3/2)*un.kB*T/np.sqrt(nat)   

    # Use slightly (10%) wider sigma to compensate 
    # for the missing tails below weight=1
    g = stats.norm(mu, sigma_scale*sigma)
    e = np.fromiter((s[-1] for s in data), float)
    idx = np.argsort(e)
    ridx = np.arange(len(idx))[idx]
    d = e[idx]
    if debug:
        N_bins = min(len(data)//4, 15)
        mh = plt.hist(d, bins=N_bins, density=True, alpha=0.3, label='Raw data')[0].max()
        plt.plot(d, -0.05*mh*np.ones(d.shape), '|', alpha=max(0.01, min(1.0, 100/len(d))))
        plt.axhline(lw=1, ls=':')
        
    bb = np.zeros(len(d)+1)
    bb[1:-1] = (d[:-1]+d[1:])/2
    bb[0] = d[0]-(d[1]-d[0])/2
    bb[-1] = d[-1]+(d[-1]-d[-2])/2
    # bin widths
    bw = bb[1:]-bb[:-1]

    cdf = g.cdf(bb)
    w = cdf[1:]-cdf[:-1]
    w /= w.sum()
    if debug:
        plt.stairs(w/bw, bb, fill=False, lw=1, label='Float weighted samples')
        x = np.linspace(e.min(), e.max(), 100)
        plt.plot(x, g.pdf(x), '-', label='Target')
        plt.hist(d, weights=w, bins=N_bins, density=True, alpha=0.3, label='Weighted data (without nonzero_w)')
        plt.xlim(mu-5*sigma, mu+5*sigma)
        plt.legend(loc='upper left', bbox_to_anchor=(0.6, 0.95))
        plt.show()

    return w, idx

# %% ../12_optimize.ipynb 10
def make_sampling(data, T, sigma_scale=1.0, probTH=0.25, Nmul=4, N=None, 
                  nonzero_w=True, debug=False, N_bins=None):
    if N is None:
        N = int(Nmul*len(data))
    if Nmul>25 :
        print('Warning: You cannot generate data from thin air. Nmul above 25 is pointless. Doing it anyway.')
    if N_bins is None :
        N_bins = min(len(data)//4, 15)
    nat = data[0][2].shape[0]
    mu = 3*T*un.kB/2
    sigma = np.sqrt(3/2)*un.kB*T/np.sqrt(nat)   

    w, idx = get_sample_weights(data, T, sigma_scale=sigma_scale, debug=debug)
    
    # Block zero weights in the +/- 3*sigma zone to not lose data
    # iw = np.round(w*nf) + (1*(np.abs(d - mu) < 3*sigma))
    iw = N*w
    if nonzero_w:
        # Don't remove low probability data, rise weights above probTH
        # This will deform (rise) the wings of the histogram
        iw[np.logical_and(probTH<iw, iw<1)]=1
    iw = np.round(iw)

    # Weight the data by multiplication of data points
    wd = []
    iwnorm = iw.sum()
    for ww, ii in zip(iw,idx):
        if ww<1:
            continue
        wd += int(ww)*[data[ii]]
    # print(len(wd), wde.shape)
    # assert len(wd) == N
    if debug:
        wde = np.fromiter((s[-1] for s in wd), float)
        h, b, _ = plt.hist(wde, bins=N_bins, density=True, alpha=0.3);
        x = np.linspace(mu-3*sigma, mu+3*sigma, 300)
        fit = stats.norm.fit(wde)
        plt.plot( x, stats.norm.pdf(x, mu, sigma), '--', 
                 label=f'$\mu$={2*mu/3/un.kB:.1f}; $\sigma$={2*sigma/3/un.kB:.1f} (Target)' )
        plt.plot( x, stats.norm.pdf(x, *fit), 
                 label=f'$\mu$={2*fit[0]/3/un.kB:.1f}; $\sigma$={2*fit[1]/3/un.kB:.1f} (Fit)' )
        plt.title('Generated weighted sample')
        skip = len(data)//2000
        skip = int(max(1, skip))
        print(skip)
        nf = (w[::skip]).max()
        for s, a in zip(data[::skip], w[::skip]):
            if a<1e-3:
                continue
            plt.axvline(s[-1], ymin=0.95, ymax=0.99, ls='-', color='r', alpha=np.sqrt(a/nf))
        plt.xlim(mu-3*sigma, mu+4*sigma)
        plt.legend(loc='upper right', bbox_to_anchor=(1.0, 0.95));
    return wd
